# -*- perl -*-
#
# gimme -- not generated by configure but by installdir/Makefile
#
# $Id: gimme.plin,v 2.2 2004/11/16 00:44:05 o Exp $
#
# philologic 2.8 -- TEI XML/SGML Full-text database engine
# Copyright (C) 2004 University of Chicago
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the Affero General Public License as published by
# Affero, Inc.; either version 1 of the License, or (at your option)
# any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Affero General Public License for more details.
# 
# You should have received a copy of the Affero General Public License
# along with this program; if not, write to Affero, Inc.,
# 510 Third Street, Suite 225, San Francisco, CA 94107 USA.

use Classic::Perl;


%fields = (
    'title',        0,
    'author',       1,
    'date',         2,
	'genre',        3,
	'publisher',    4,
	'pubplace',     5,
	'extent',       6,
	'editor',       7,
	'pubdate',      8,
	'createdate',   9,
	'authordates',  10,
	'keywords',     11,
	'language',     12,
	'collection',   13,
	'gender',       14,
	'sourcenote',   15,
	'period',       16,
	'shrtcite',     17,
	'filename',     18,
	'filesize',     19,
        'number',       20 
);

%numeric = (
	'date',		1
);

%exact = (
);

%ACCENTS = (
   'A',    "(a|\xc3\xa0|\xc3\xa1|\xc3\xa2|\xc3\xa3|\xc3\xa4|\xc3\x82)",
   'C',    "(c|\xc3\xa7|\xc3\x87)",
   'E',    "(e|\xc3\xa8|\xc3\xa9|\xc3\xaa|\xc3\xab|\xc3\x89|\xc3\x88|\xc3\x8A)",
   'I',    "(i|\xc3\xac|\xc3\xad|\xc3\xae|\xc3\xaf)",
   'N',    "(n|\xc3\xb1)",
   'O',    "(o|\xc3\xb2|\xc3\xb3|\xc3\xb4|\xc3\xb4|\xc3\xb6|\xc3\x94)",
   'U',    "(u|\xc3\xb9|\xc3\xba|\xc3\xbb|\xc3\xbc)",  
   'Y',    "(y|\xc3\xbf|xc3\xbd)" );


###################################################
#########you do not have to edit anything##########
#########        beyond this line!       ##########
###################################################

$EGREP = "...EGREP...";

$SYSTEM_DIR = $ENV{'SYSTEM_DIR'};

if ($ARGV[0] eq "-debug") {shift @ARGV; $debug++;}

if ($ARGV[0] eq "-v") {shift @ARGV; $verbose++;}

FOO:
while ($arg = shift (@ARGV))
  {

       ($arg, $value) = split ("=", $arg);

       next FOO if !$value;

       $c = $fields{$arg};

       $patterns [$c] = &Numeric ($value),
         next FOO if $numeric{$arg};

       &cleanpattern;

       $value  = "[^\t]*" . $value . "[^\t]*"
	   unless $exact{$arg};
       $patterns [$c] = $value;
  }   

$pattern = &Cook_Final_Pattern;

print STDERR $pattern . "\n" if $debug;

if ( $verbose ) 
{
   system ("$EGREP -i -e \"$pattern\" < $SYSTEM_DIR/bibliography"); 
}
else
{
    open P, "$EGREP -i -e \"$pattern\" < $SYSTEM_DIR/bibliography |";

    while (<P>)
    {
	chop; 
	split ("\t", $_); 
	
	print pack ('i', $_[$#_]);
    }

}

############################################################
###########Subroutines. Do not even look there!#############
############################################################

sub Cook_Final_Pattern {
local ( $gap, $len, $maxgap, $pattern);
local ( @keys);

    @keys = keys %fields;
    $len = $#keys + 1;

    while ( $len-- )
       {
	  if (! $patterns[$len])
	     {
		 $patterns[$len] = "%";
		 $gap++;
		 $maxgap = $gap if $gap > $maxgap;
	     }
	  else 
	     {
		 $gap = 0;
             }
       }

     $pattern = '^' . join ("\t", @patterns) . '$'; 

     $maxgap--;

     if ($pattern !~ /(%\t){$maxgap}%/)
        {
           print STDERR "Hi Mark!\n";
           print STDERR "This is my debuggin message; you are NOT supposed\n";
           print STDERR "to see it. ;) \n";
           print STDERR "Something wrong (gap): $pattern\n";
        }

     $pattern =~ s/\^?(%@){$maxgap}%\$?/.*/;
     $pattern =~ s/%/[^\t]*/g;
return $pattern; 
}


sub Numeric {
local ($range) = $_[0];
local ($l, $u, $len, $format);

#  return "[^@]*" if !$range;

  ($l, $u) = split ("-", $range);

  $u = $l unless $u;

  $len = &max (length($l), length($u));
  $format = "%0" . $len . "d";

  $l = sprintf ($format, $l);
  $u = sprintf ($format, $u);

  return &num_pattern ($l, $u);
}


sub cleanpattern {

  $value =~ s/\+OR\+/\|/g;
  $value =~ s/[ACEINOUY]/$ACCENTS{$&}/ge;

  $value =~ tr/A-Z+/a-z /;
# L.A. jan 8 '99:  $value =~ s/, */|/g;
#   $value =~ s/, */,/g;
  $value =~ s/\"//g;
  $value =~ s/^.*\|.*$/($&)/;

}


sub num_pattern {
local ($l, $r) = @_;
local ($pat, $len, $mid, $c, $i);
local ($first);
local (@pats, @l, @r);

# Trivial cases:
# if we have a range where lower bound is equal to the upper one,
# reduce it to scalar:
# (i.e. 187-187 is reduced to 187)

if ( $l == $r ) { return $l; } 

# if we have a range with single-digit bounds N-M, translate it 
# into [N-M]

if (($len = length($l)) == 1)
   {
      $pat = "[" . $l . "-" . $r . "]";	
      return $pat;
   }

$c = $len - 1;

@l = split("", $l);
@r = split("", $r);

# let's check if we have NNN00...0-MMM99...9 range

if ( $l[$c] == 0 && $r[$c] == 9 )
   {
      while ( $l[$#l] == 0 && $r[$#r] == 9 )
	  {
	      pop (@l);
	      pop (@r);
              $pat .= "[0-9]";
          }
      $pat =  
	 &num_pattern ( join("",@l), join ("",@r)) . $pat;
      return $pat;
   }

# Next case: left and right bounds have the same "head":

if ( $l[0] == $r[0] )
   {
      while (($first = $l[0]) == $r[0] )
          {
              shift (@l);
              shift (@r);
	      $pat .= $first;
          }

      $pat .= 
	 &num_pattern ( join("",@l), join ("",@r));
      return $pat;
   }

# No more trivial cases; let's split the remaining range into
# three parts -- left, right and middle;
# for ex., 243-645 splits into 243-299, 300-599, 600-645
# Note, that at least one of the parts can be empty!
# (e.g. 400-543 splits into (null), 400-499 and 500-543)

$mid = $r[0] - $l[0] - 1;

# Left part:

if ( $l!~/^[0-9]?0*$/ )
   {
      $pat = $l[0];
      for ($i=0; $i<$c; $i++) { $pat .= "9"; }

      $pat = &num_pattern ($l, $pat);
      $pats[0] = $pat;

   }
else
   {
      $l[0]--;
      $mid++;
   }

# Right part:

if ( $r!~/^.?9*$/ )
   {
     $pat = "";

     for ($i=0; $i<$c; $i++) { $pat .= "0"; }

     $pat = $r[0] . $pat;
     $pat = &num_pattern ($pat, $r);

     $pats[2] = $pat;
     $rp = $pat;
   }
else 
   {
     $r[0]++;
     $mid++;
   }

# And the middle:

if ( $mid )
   {

      $pat = $mid == 1 ? $l[0] + 1 :
      "[" . ($l[0]+1) . "-" . ($r[0]-1) . "]";

      for ($i=0; $i<$c; $i++) { $pat .= "[0-9]"; }
 
      $pats[1] = $pat;
   }

# I'm getting rid of empty patterns (parts):

@pats = grep (!/^$/, @pats);

# Now we can return the final pattern; let's not forget about
# parentheses!

$pat = "(" . join ("|", @pats) . ")";
return $pat;
} 

sub max 
{
  return $_[0]>$_[1] ? $_[0] : $_[1];
}



