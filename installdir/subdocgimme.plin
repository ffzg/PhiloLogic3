#!@PERL@ # might not be needed or might be doubled...
# -*- perl -*-
# subdocgimme -- not generated by configure but by installdir/Makefile
# $Id: subdocgimme.plin,v 2.2 2004/11/16 00:44:05 o Exp $
#
# philologic 2.8 -- TEI XML/SGML Full-text database engine
# Copyright (C) 2004 University of Chicago
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the Affero General Public License as published by
# Affero, Inc.; either version 1 of the License, or (at your option)
# any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# Affero General Public License for more details.
# 
# You should have received a copy of the Affero General Public License
# along with this program; if not, write to Affero, Inc.,
# 510 Third Street, Suite 225, San Francisco, CA 94107 USA.

# This is a sequential search for either divindex or subdivindex based
# on the ancient gimme script.  

# ARGS: -debug -v and then one of -div -subdiv

$SYSTEM_DIR = $ENV{'SYSTEM_DIR'};
$EGREP = "...EGREP...";

# Process command line args
if ($ARGV[0] eq "-debug") {shift @ARGV; $debug++;}
if ($ARGV[0] eq "-v") {shift @ARGV; $verbose++;}
if ($ARGV[0] eq "-div") {shift @ARGV; $divlevel++;}
if ($ARGV[0] eq "-subdiv") {shift @ARGV; $subdivlevel++;}

if (!$divlevel && !$subdivlevel) {
	$divlevel++;
}

if ($divlevel) {
	$thedatafile = $SYSTEM_DIR . "/divindex.raw";
	$objectdepth = 4;
	%fields = (
    		'dgphilodivid', 	0,
    		'dgdivhead',    	1,
    		'dgdivtype',    	2,
		'dgdivlang',    	3,
		'dgdivn',       	4,
		'dgdivid',      	5,
		'dgdivocauthor',	6,
		'dgdivocdateline',	7,
		'dgdivocplacename',	8,
		'dgdivocsalutation',	9,
		'dgdivocclassification', 10,
		'dgdivocpartofspeech',	11,
		'dgdivxpath',   	12,
		'dgphilodocid', 	13
		);
	%numeric = ( 
 		'dgphilodocid',		1
		);
	%exact = (
		);
        # This is to expand the list of sub objects to search....
        # we will probably not need it when Leonid fixes search3 to
        # handle -1 args.....
	if (!$verbose) {
		$thechildfile = $SYSTEM_DIR . "/dividxchild.tab";
		if (-e $thechildfile) {
			open(THEDIVCHILD, $thechildfile);
			while ($linein = <THEDIVCHILD>) {
				$linein =~ s/\n//;
				($thekey, $thekids) = split("\t", $linein);
				$thedivkids{$thekey} = $thekids;
				$numofkids++;
				}
			close(THEDIVCHILD);
			}
		}
	}
else {
        $thedatafile = $SYSTEM_DIR . "/subdivindex.raw";
        $objectdepth = 5;
        %fields = (
                'dgphilosubdivid',  0,
                'dgsubdivtag',      1,
                'dgsubdivtype',     2,
                'dgsubdivn',        3,
                'dgsubdivid',       4,
                'dgsubdivwho',      5,
                'dgsubdivlang',     6,
                'dgsubdivxpath',    7,
                'dgphilodocid',     8
                );
        %numeric = (
                'dgphilodocid',         1
                );
        %exact = (
                );
}

# This should come from philo-db.cfg

%ACCENTS = ( 'A',       "(a|\xc3\xa0|\xc3\xa1|\xc3\xa2|\xc3\xa3|\xc3\xa4)",
             'C',       "(c|\xc3\xa7)",
             'E',       "(e|\xc3\xa8|\xc3\xa9|\xc3\xaa|\xc3\xab)",
             'I',       "(i|\xc3\xac|\xc3\xad|\xc3\xae|\xc3\xaf)",
             'N',       "(n|\xc3\xb1)",
             'O',       "(o|\xc3\xb2|\xc3\xb3|\xc3\xb4|\xc3\xb4|\xc3\xb6)",
             'U',       "(u|\xc3\xb9|\xc3\xba|\xc3\xbb|\xc3\xbc)",
             'Y',       "[y\375\377]"   );


###################################################
#########you do not have to edit anything##########
#########        beyond this line!       ##########
###################################################

FOO:
while ($arg = shift (@ARGV)) {
       ($arg, $value) = split ("=", $arg);
       next FOO if !$value;
       $c = $fields{$arg};
       $patterns [$c] = &Numeric ($value),
         next FOO if $numeric{$arg};
       &cleanpattern;
       $value  = "[^\t]*" . $value . "[^\t]*"
	   unless $exact{$arg};
       $patterns [$c] = $value;
  }   

$pattern = &Cook_Final_Pattern;

if ($debug) {
	print STDERR $thedatafile . "\n";
	print STDERR $pattern . "\n";
}	

if ($verbose) {
   system ("$EGREP -i -e \"$pattern\" < $thedatafile"); 
   }
else {
   open P, "$EGREP -i -e \"$pattern\" < $thedatafile |";
#   open (TESTOUT, ">/tmp/mvotestout1");
#   print TESTOUT "$thechildfile \n";
#   print TESTOUT "$numofkids \n";
    while (<P>) {
	chop; 
	@result = split ("\t", $_); 
#	print TESTOUT "\n>>> $result[0]";
	if ($numofkids) {
		$inkids = "";
		$inkids = $thedivkids{$result[0]};
#                print TESTOUT "\n+++ $inkids\n";
		}
	if ($inkids) {
		&PrintDivChildren($inkids);
		}
	else {
		@xxx = split(":", $result[0]);
		$nullvalue = "0";
		for ($i=0; $i < $objectdepth; $i++) {
			if (length($xxx[$i]) < 1) {
				$xxx[$i] = $nullvalue;
				$nullvalue = "-1";	
			}
#			print TESTOUT "$xxx[$i] == ";
			print pack ('i', $xxx[$i]);
		}
	}
	
    }

}

############################################################
###########Subroutines. Do not even look there!#############
############################################################

sub PrintDivChildren() {
	local ($allthekids, $children, $kid, $nn, $nullvalue);
	$allthekids = $_[0];
	@children = split (/\|/, $allthekids);
	foreach $kid (@children) {
		print TESTOUT "$kid\n";
		@nn = split(/:/, $kid);
		$nullvalue = "0";
		for ($i=0; $i < $objectdepth; $i++) {
			if (length($nn[$i]) < 1 ) {
				$nn[$i] = $nullvalue;
				$nullvalue = "-1";
				}
#			print TESTOUT "$nn[$i] -- ";
			print pack ('i', $nn[$i]);
			}
		}	
	print TESTOUT "\n";
	}


sub Cook_Final_Pattern {
local ( $gap, $len, $maxgap, $pattern);
local ( @keys);

    @keys = keys %fields;
    $len = $#keys + 1;

    while ( $len-- )
       {
	  if (! $patterns[$len])
	     {
		 $patterns[$len] = "%";
		 $gap++;
		 $maxgap = $gap if $gap > $maxgap;
	     }
	  else 
	     {
		 $gap = 0;
             }
       }

     $pattern = '^' . join ("\t", @patterns) . '$'; 

     $maxgap--;

     if ($pattern !~ /(%\t){$maxgap}%/)
        {
           print STDERR "Hi Mark!\n";
           print STDERR "This is my debuggin message; you are NOT supposed\n";
           print STDERR "to see it. ;) \n";
           print STDERR "Something wrong (gap): $pattern\n";
        }

     $pattern =~ s/\^?(%@){$maxgap}%\$?/.*/;
     $pattern =~ s/%/[^\t]*/g;
return $pattern; 
}


sub Numeric {
local ($range) = $_[0];
local ($l, $u, $len, $format);

#  return "[^@]*" if !$range;

  ($l, $u) = split ("-", $range);

  $u = $l unless $u;

  $len = &max (length($l), length($u));
  $format = "%0" . $len . "d";

  $l = sprintf ($format, $l);
  $u = sprintf ($format, $u);

  return &num_pattern ($l, $u);
}


sub cleanpattern {

  $value =~ s/\+OR\+/\|/g;
  $value =~ s/[ACEINOUY]/$ACCENTS{$&}/ge;

  $value =~ tr/A-Z+/a-z /;
# L.A. jan 8 '99:  $value =~ s/, */|/g;
#   $value =~ s/, */,/g;
  $value =~ s/\"//g;
  $value =~ s/^.*\|.*$/($&)/;

}


sub num_pattern {
local ($l, $r) = @_;
local ($pat, $len, $mid, $c, $i);
local ($first);
local (@pats, @l, @r);

# Trivial cases:
# if we have a range where lower bound is equal to the upper one,
# reduce it to scalar:
# (i.e. 187-187 is reduced to 187)

if ( $l == $r ) { return $l; } 

# if we have a range with single-digit bounds N-M, translate it 
# into [N-M]

if (($len = length($l)) == 1)
   {
      $pat = "[" . $l . "-" . $r . "]";	
      return $pat;
   }

$c = $len - 1;

@l = split("", $l);
@r = split("", $r);

# let's check if we have NNN00...0-MMM99...9 range

if ( $l[$c] == 0 && $r[$c] == 9 )
   {
      while ( $l[$#l] == 0 && $r[$#r] == 9 )
	  {
	      pop (@l);
	      pop (@r);
              $pat .= "[0-9]";
          }
      $pat =  
	 &num_pattern ( join("",@l), join ("",@r)) . $pat;
      return $pat;
   }

# Next case: left and right bounds have the same "head":

if ( $l[0] == $r[0] )
   {
      while (($first = $l[0]) == $r[0] )
          {
              shift (@l);
              shift (@r);
	      $pat .= $first;
          }

      $pat .= 
	 &num_pattern ( join("",@l), join ("",@r));
      return $pat;
   }

# No more trivial cases; let's split the remaining range into
# three parts -- left, right and middle;
# for ex., 243-645 splits into 243-299, 300-599, 600-645
# Note, that at least one of the parts can be empty!
# (e.g. 400-543 splits into (null), 400-499 and 500-543)

$mid = $r[0] - $l[0] - 1;

# Left part:

if ( $l!~/^[0-9]?0*$/ )
   {
      $pat = $l[0];
      for ($i=0; $i<$c; $i++) { $pat .= "9"; }

      $pat = &num_pattern ($l, $pat);
      $pats[0] = $pat;

   }
else
   {
      $l[0]--;
      $mid++;
   }

# Right part:

if ( $r!~/^.?9*$/ )
   {
     $pat = "";

     for ($i=0; $i<$c; $i++) { $pat .= "0"; }

     $pat = $r[0] . $pat;
     $pat = &num_pattern ($pat, $r);

     $pats[2] = $pat;
     $rp = $pat;
   }
else 
   {
     $r[0]++;
     $mid++;
   }

# And the middle:

if ( $mid )
   {

      $pat = $mid == 1 ? $l[0] + 1 :
      "[" . ($l[0]+1) . "-" . ($r[0]-1) . "]";

      for ($i=0; $i<$c; $i++) { $pat .= "[0-9]"; }
 
      $pats[1] = $pat;
   }

# I'm getting rid of empty patterns (parts):

@pats = grep (!/^$/, @pats);

# Now we can return the final pattern; let's not forget about
# parentheses!

$pat = "(" . join ("|", @pats) . ")";
return $pat;
} 

sub max 
{
  return $_[0]>$_[1] ? $_[0] : $_[1];
}



